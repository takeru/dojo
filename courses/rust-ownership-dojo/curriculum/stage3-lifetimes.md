# Stage 3: ライフタイム基礎

## 目標

このステージを完了すると、生徒は：
- ライフタイムの概念を理解できる
- ライフタイム注釈の書き方を理解できる
- ライフタイム省略規則の基本を理解できる
- 簡単なライフタイム問題を解決できる

## 前提知識

- Stage 2完了（借用と参照の理解）
- 関数とジェネリクスの基本

## 関連する発展トピック（サブクエスト）

このステージをクリアした後、以下のトピックで深く学べます：
- **lifetime-elision** - ライフタイム省略規則

## 教え方ガイド

### 導入（なぜこれを学ぶか）

参照には「生存期間」があり、その参照が有効である期間を明示的に示す必要がある場合があります。ライフタイムは、参照が常に有効であることをコンパイラが保証するための仕組みです。

### 説明の流れ

1. **ライフタイムとは何か**
   ```rust
   {
       let r;                // ---------+-- 'a
                            //          |
       {                    //          |
           let x = 5;       // -+-- 'b  |
           r = &x;          //  |       |
       }                    // -+       |
                            //          |
       // println!("{}", r); // エラー！xはもう存在しない
   }                        // ---------+
   ```

2. **ライフタイム注釈の書き方**
   ```rust
   fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
       if x.len() > y.len() {
           x
       } else {
           y
       }
   }
   ```

3. **ライフタイムの意味**
   - `'a`はライフタイムパラメータ
   - 「返される参照は、xとyの短い方のライフタイムを持つ」という意味

4. **構造体とライフタイム**
   ```rust
   struct ImportantExcerpt<'a> {
       part: &'a str,
   }

   fn main() {
       let novel = String::from("Call me Ishmael. Some years ago...");
       let first_sentence = novel.split('.').next().unwrap();
       let i = ImportantExcerpt {
           part: first_sentence,
       };
   }
   ```

### よくある間違い

- ライフタイム注釈を「参照の生存期間を変える」と誤解 → 注釈は制約を表すだけ
- すべての参照にライフタイム注釈が必要だと思う → 省略規則を説明
- ライフタイム構文が読めない → `'a`の読み方と意味を丁寧に

## 演習課題

### 課題1: 基本的なライフタイム注釈
2つの文字列参照を受け取り、長い方を返す関数を、ライフタイム注釈付きで書いてください。

### 課題2: 構造体のライフタイム
参照を含む構造体を定義し、ライフタイム注釈を追加してください。

### 課題3: ライフタイムエラーの解決
意図的にライフタイムエラーを起こし、コンパイラのメッセージを読んで修正してください。

## 評価基準

以下がすべて満たされたらステージクリア：

- [ ] ライフタイムの概念を説明できる
- [ ] ライフタイム注釈の書き方を理解している
- [ ] 簡単なライフタイム注釈を関数に追加できる
- [ ] ライフタイムエラーのメッセージを理解できる

## ヒント集

### ヒント1（軽め）
ライフタイムは、「この参照はどれくらいの期間有効か」を示します。

### ヒント2（中程度）
ライフタイム注釈は`'a`のように書きます。ジェネリック型パラメータ`<T>`と同じく、`<'a>`として宣言します。

### ヒント3（具体的）
```rust
// 戻り値のライフタイムは、引数のライフタイムに依存
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string");
    let string2 = String::from("xyz");

    let result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);
}
```

## 補足・発展トピック

### トピック1: ライフタイム省略規則

**質問**: いつもライフタイム注釈を書かないといけないの？

**説明**:
多くの場合、Rustコンパイラはライフタイムを自動推論できます。以下の省略規則があります：

1. 各引数パラメータは独自のライフタイムを持つ
2. 引数が1つなら、そのライフタイムが戻り値に使われる
3. 引数に`&self`や`&mut self`があれば、selfのライフタイムが戻り値に使われる

例：
```rust
// これは
fn first_word(s: &str) -> &str {

// 実際には
fn first_word<'a>(s: &'a str) -> &'a str {
// と同じ
```

### トピック2: 'staticライフタイム

**質問**: `'static`って何？

**説明**:
`'static`は特別なライフタイムで、「プログラム全体の期間」を意味します。

```rust
let s: &'static str = "I have a static lifetime.";
```

文字列リテラルは常に`'static`ライフタイムを持ちます（プログラムのバイナリに直接埋め込まれるため）。

### トピック3: ライフタイムと借用チェッカー

**質問**: 借用チェッカーはどうやってライフタイムを確認してるの？

**説明**:
借用チェッカーは、参照が参照先よりも長生きしないことを確認します。

```rust
{
    let r;                 // ---------+-- 'a
    {                      //          |
        let x = 5;         // -+-- 'b  |
        r = &x;            //  |       |
    }                      // -+       |
    println!("{}", r);     // エラー！'b < 'a
}
```

### 参考リンク

- The Rust Book: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
- Rust By Example: https://doc.rust-lang.org/rust-by-example/scope/lifetime.html
- Rustonomicon: https://doc.rust-lang.org/nomicon/lifetimes.html
