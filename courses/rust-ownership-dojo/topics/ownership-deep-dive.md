# 発展トピック: 所有権の詳細とムーブセマンティクス

## 概要

所有権システムの基本を理解した上で、さらに深く掘り下げます。スタック/ヒープの違い、ムーブの必要性、実務パターンなど、実際にコードを書く際に役立つ知識を学びます。

## 前提知識

- Stage 1: 所有権の完了
- 所有権の3つのルール
- ムーブとコピーの基本的な違い

## 学習時間

15分程度

## 学習目標

このトピックを完了すると、以下ができるようになります：

- スタックとヒープの違いを説明できる
- なぜムーブが必要かを理解できる（ダブルフリー問題）
- cloneとcopyの使い分けができる
- 所有権と関数の実務パターンを理解できる
- リファレンスカウントとの違いを説明できる

---

## 要点

### 1. スタックとヒープの違い

**スタック（Stack）**:
- 超高速（CPUが直接アクセス）
- サイズが固定の値を保存
- 例: i32, bool, char, (i32, i32)

**ヒープ（Heap）**:
- 少し遅い（メモリアロケータ経由）
- サイズが可変の値を保存
- 例: String, Vec, Box

```rust
let x = 5;                      // スタックに保存
let s = String::from("hello");  // ヒープに保存、sはポインタ
```

Stringは内部的に3つの値を持つ：
1. **ptr** - ヒープ上のデータへのポインタ
2. **len** - 現在の長さ
3. **capacity** - 確保済みの容量

### 2. なぜムーブが必要か？

もしムーブを強制しなかったら、**ダブルフリー**（同じメモリを2回解放）が発生する：

```rust
let s1 = String::from("hello");
let s2 = s1;  // ムーブ

// もしムーブせずに両方が使えたら...
// drop(s1);  // s1がメモリを解放
// drop(s2);  // s2も同じメモリを解放 → ダブルフリー！💥
```

Rustの所有権システムは、このバグをコンパイル時に防ぐ。

### 3. cloneとcopyの使い分け

```rust
// clone: 明示的に複製（ヒープのデータもコピー）
let s1 = String::from("hello");
let s2 = s1.clone();  // コストがかかる
println!("{} {}", s1, s2);

// copy: 暗黙的に複製（Copyトレイト実装型のみ）
let x = 5;
let y = x;  // 自動的にコピー（高速）
println!("{} {}", x, y);
```

**使い分け**:
- `copy`: 軽い型（i32, bool等）は自動
- `clone`: 重い型（String, Vec等）は明示的に`.clone()`
- `.clone()`はコストがかかるため、必要最小限に

### 4. 所有権と関数 - 返却パターン

```rust
fn takes_and_gives_back(s: String) -> String {
    println!("{}", s);
    s  // 所有権を返す
}

fn main() {
    let s1 = String::from("hello");
    let s2 = takes_and_gives_back(s1);
    println!("{}", s2);  // OK
    // println!("{}", s1);  // エラー
}
```

実務では同じ変数名で受け取ることも多い（シャドーイング）：

```rust
fn process_data(data: Vec<i32>) -> Vec<i32> {
    let mut result = data;
    result.push(100);
    result
}

fn main() {
    let numbers = vec![1, 2, 3];
    let numbers = process_data(numbers);  // 同じ名前で受け取る
    println!("{:?}", numbers);
}
```

### 5. 所有権 vs リファレンスカウント

**Rustのデフォルト所有権**:
- リファレンスカウンタなし
- コンパイル時にすべてチェック
- 実行時オーバーヘッドゼロ
- 所有者は常に1人

**リファレンスカウント（Rc）**:
- 実行時にカウント管理（1→2→1→0）
- 複数の所有者が必要な場合に使用
- わずかなオーバーヘッドあり

```rust
use std::rc::Rc;

let s1 = Rc::new(String::from("hello"));
let s2 = Rc::clone(&s1);  // カウント増加
println!("{} {}", s1, s2);  // 両方使える
```

---

## 対話形式の教え方ガイド

### 導入

「お、所有権を深掘りするんだ！いいね！Stage 1で基本は分かったと思うけど、実務でよく出てくるパターンとか、なぜそうなるのかをもっと掘り下げていこう！」

### ステップ1: スタックとヒープ

**説明**:
「さっき『Stringはヒープ、i32は軽い』って言ってたけど、これもう少し詳しく説明するね」

- スタックは超高速、サイズ固定
- ヒープは可変サイズ、少し遅い
- Stringの内部構造（ptr, len, capacity）を図で説明

**確認質問**:
「Stringがスタックとヒープの両方を使うのはなぜだと思う？」

### ステップ2: ダブルフリー問題

**実験**:
```rust
let s1 = String::from("hello");
let s2 = s1;  // ムーブ
```

**説明**:
「もしムーブを強制しなかったら、同じメモリを2回解放するバグが起きちゃう。これはセキュリティの脆弱性にもなる重大なバグなんだよね」

**確認質問**:
「なぜダブルフリーが危険なの？」

### ステップ3: cloneとcopy

**実験**:
```rust
// clone
let s1 = String::from("hello");
let s2 = s1.clone();
println!("{} {}", s1, s2);

// copy
let x = 5;
let y = x;
println!("{} {}", x, y);
```

**確認質問**:
「なんで`.clone()`にコストがかかるの？」

期待する答え: 「ヒープにある実際のデータを丸ごとコピーするから」

### ステップ4: 実務パターン

**例を示す**:
- 関数での所有権返却パターン
- シャドーイングの使い方

**説明**:
「でもこれ、ちょっと面倒じゃない？毎回返却するの... だから実際には借用（&）を使うことが多いんだけど、それはStage 2で学ぶよ！」

### ステップ5: リファレンスカウントとの違い

**質問から入る**:
「リファレンスカウンタの増減を自動で1→2→1→0ってやってる感じ？」（生徒が聞いてきそうな質問）

**答え**:
「いい線いってるけど、実はRustの所有権システムはリファレンスカウンタなしなんだよ！これがRustのすごいところ！」

- 所有権 = カウント無し、コンパイル時チェック
- Rc = 明示的なリファレンスカウント

### まとめ

「ここまでで、所有権についてかなり深く理解できたと思う！」

チェック項目：
- スタックとヒープの違い
- なぜムーブが必要か
- cloneとcopyの使い分け
- 関数での所有権パターン
- リファレンスカウントとの違い

---

## クリア条件

以下の質問に答えられること：

1. スタックとヒープの違いは？
2. なぜムーブが必要なのか？（ダブルフリー問題）
3. `.clone()`にコストがかかるのはなぜ？
4. デフォルトの所有権とRc<T>の違いは？

または、対話形式で先生が理解度を確認し、十分理解していると判断した場合。

---

## 参考リンク

- The Rust Book - Ownership: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
- Rust By Example - Move: https://doc.rust-lang.org/rust-by-example/scope/move.html
- The Rustonomicon - Ownership: https://doc.rust-lang.org/nomicon/ownership.html
- std::rc::Rc documentation: https://doc.rust-lang.org/std/rc/struct.Rc.html

---

## よくある質問

**Q: ownerって変数のこと？**
A: ownerは「変数と値の関係」。変数がその値の「所有者」という関係性のこと。Copyトレイトの有無に関係なく、すべての値にownerがいる。

**Q: 値ってヒープのメモリのこと？**
A: 値は実際のデータのこと。Copyトレイトがない型（String）の場合はヒープ上のデータ、Copyトレイトがある型（i32）の場合はスタック上の数値そのものが値。

**Q: いつもcloneを使えばいいんじゃない？**
A: cloneはコストがかかるため、本当に必要な時だけ使う。実務では借用（&）を使うことが多い（Stage 2で学習）。

**Q: Rcはいつ使う？**
A: グラフ構造やキャッシュなど、複数の場所から同じデータを参照する必要がある場合。通常の所有権システムで解決できないケースでのみ使用する。
