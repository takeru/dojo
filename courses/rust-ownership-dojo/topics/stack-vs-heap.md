# トピック: スタックとヒープの違い

## メタ情報

- **ID**: stack-vs-heap
- **難易度**: 初級〜中級
- **所要時間**: 10-15分（対話形式）/ 5分（読み物）
- **カテゴリ**: メモリモデル

## 前提知識

- Stage 1の所有権の基礎（ムーブとコピーの違い）
- 変数と値の概念

## このトピックで学べること

- スタックとヒープの違い
- なぜ`i32`はコピーで`String`はムーブなのか
- メモリ配置がRustの所有権設計にどう影響しているか
- パフォーマンスへの影響

## 関連ステージ

- Stage 1: 所有権（ムーブとコピーの理解を深める）

## 要点（ドキュメント形式用）

Rustが値をどこに保存するかで、所有権の挙動が変わります。

### スタック（Stack）

- **固定サイズ**のデータを保存
- 高速（LIFOで単純なポインタ操作）
- 関数呼び出しごとにフレームが積まれ、戻ると解放
- 例: `i32`, `f64`, `bool`, `char`, 固定長配列

```rust
fn main() {
    let x: i32 = 42;      // スタックに4バイト確保
    let y: [i32; 3] = [1, 2, 3];  // スタックに12バイト確保
}
```

### ヒープ（Heap）

- **可変サイズ**のデータを保存
- 動的に確保・解放（少し遅い）
- 明示的な管理が必要（Rustでは所有権システムが自動管理）
- 例: `String`, `Vec<T>`, `Box<T>`

```rust
fn main() {
    let s = String::from("hello");  // ヒープに文字列データ
    // スタックには(ptr, len, capacity)の3ワード = 24バイト
}
```

### なぜ挙動が違うのか

**スタック上のデータ（Copy型）**:
- サイズが固定で小さい
- コピーが安価（メモリを単純にコピーするだけ）
- 複数の変数が同じ値の「コピー」を持てる

```rust
let x = 5;
let y = x;  // 5がコピーされる（4バイトのメモリコピー）
println!("{}", x);  // OK: xは独立した値
```

**ヒープ上のデータ（Move型）**:
- サイズが可変または大きい
- 深いコピーは高コスト
- 所有権をムーブして、二重解放を防ぐ

```rust
let s1 = String::from("hello");
let s2 = s1;  // 所有権がムーブ（ヒープデータはコピーされない）
// println!("{}", s1);  // エラー: s1は無効
```

### メモリレイアウトの図

```
スタック                    ヒープ
┌───────────┐
│ x = 5     │  ← i32は直接スタックに
└───────────┘

┌───────────┐              ┌─────────────┐
│ s1        │              │ "hello"     │
│  ptr ─────┼─────────────→│ (5 bytes)   │
│  len = 5  │              └─────────────┘
│  cap = 5  │
└───────────┘

s2 = s1 の後:

┌───────────┐              ┌─────────────┐
│ s1        │              │ "hello"     │
│  (無効)   │              │ (5 bytes)   │
└───────────┘              └─────────────┘
                                 ↑
┌───────────┐                    │
│ s2        │                    │
│  ptr ─────┼────────────────────┘
│  len = 5  │
│  cap = 5  │
└───────────┘
```

## 対話形式の教え方ガイド（先生用）

### 導入

「なぜ`i32`は代入してもまだ使えるのに、`String`はムーブして使えなくなるのか…不思議に思わなかったか？その謎を解く鍵は、**メモリの配置場所**にあるのじゃ」

なぜこれを知っておくと便利か：
- 所有権の挙動が「なぜそうなるか」が腑に落ちる
- パフォーマンスを意識したコードが書ける
- `Clone`と`Copy`の使い分けが直感的になる

### 説明の流れ

1. **スタックとヒープの存在を確認**
   「まず、プログラムには2種類のメモリ領域があるのじゃ」

   ```rust
   fn main() {
       let x = 42;                    // スタック
       let s = String::from("hello"); // ヒープ + スタック
   }
   ```

   「`x`の値はスタックに直接保存される。しかし`s`は、ヒープにデータを置き、スタックにはそのポインタを持つのじゃ」

2. **なぜ分けるのか？**
   「スタックは固定サイズのデータしか置けん。`i32`は常に4バイト。しかし`String`は長さが変わりうる。"hello"は5バイトじゃが、後で"hello world"に変えたら11バイト必要じゃ」

3. **コピーのコストを体感させる**
   ```rust
   // これは安い（4バイトのコピー）
   let x = 42;
   let y = x;

   // これは高い（1MBのヒープデータをコピー？）
   let s = String::from("a".repeat(1_000_000));
   let t = s.clone();  // 明示的にクローンする必要がある
   ```

   「1MBのデータを毎回コピーしていたら遅くなる。だからRustは、ヒープデータはデフォルトでムーブして、コピーは明示的に`clone()`するのじゃ」

4. **Copyトレイトの条件**
   「`Copy`トレイトを実装できるのは、スタックに収まる固定サイズの型だけじゃ」

   ```rust
   // Copy可能
   let x: i32 = 5;
   let y = x;  // コピー

   // Copy不可能（ヒープを使うため）
   let s: String = String::from("hi");
   let t = s;  // ムーブ
   ```

### 実践課題（オプション）

1. `std::mem::size_of::<i32>()`と`std::mem::size_of::<String>()`を比較してみる
2. 大きな`Vec`を作って`clone()`の時間を測ってみる

## クリア条件（オプション）

理解度チェック：
- [ ] スタックとヒープの違いを説明できる
- [ ] `i32`がCopyで`String`がMoveな理由を説明できる
- [ ] `String`のメモリレイアウト（ptr, len, cap）を図示できる

## 補足情報

### スタックとヒープの速度差

```rust
use std::time::Instant;

fn main() {
    // スタック（高速）
    let start = Instant::now();
    for _ in 0..1_000_000 {
        let x: [i32; 100] = [0; 100];
    }
    println!("Stack: {:?}", start.elapsed());

    // ヒープ（やや遅い）
    let start = Instant::now();
    for _ in 0..1_000_000 {
        let v: Vec<i32> = vec![0; 100];
    }
    println!("Heap: {:?}", start.elapsed());
}
```

### 参考リンク

- The Rust Book: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap
- Rust By Example: https://doc.rust-lang.org/rust-by-example/std/box.html
