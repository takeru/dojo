# トピック: 型推論の仕組み

## メタ情報

- **ID**: type-inference
- **難易度**: 初級
- **所要時間**: 8-12分（対話形式）/ 4-5分（読み物）
- **カテゴリ**: 変数・型

## 前提知識

- Stage 3完了（変数と型）
- 基本的な型の種類

## このトピックで学べること

- 型推論がどのように機能するか
- コンパイラがどこから型情報を得るか
- 型推論が失敗する場面と対処法

## 関連ステージ

- Stage 3: 変数と型（ここで登場）
- Stage 4以降: より複雑な型推論

## 要点（ドキュメント形式用）

### 型推論とは

Rustのコンパイラは、明示的に型を書かなくても、様々な情報から型を推論できます。

```rust
let x = 5;      // i32 と推論される
let y = 5.5;    // f64 と推論される
let z = true;   // bool と推論される
```

### 推論の3つのソース

**1. リテラル値から推論**:
```rust
let x = 5;      // i32（整数リテラル）
let y = 5.5;    // f64（浮動小数点リテラル）
let z = "hello";  // &str（文字列リテラル）
```

**2. 操作から推論**:
```rust
let x = 5;
let y = x + 2;  // x が i32 なので y も i32
```

**3. 使用方法から推論**:
```rust
fn print_number(n: i32) {
    println!("{}", n);
}

let x = 42;
print_number(x);  // print_number が i32 を要求するので x は i32
```

### 型推論が失敗する場面

**あいまいな場合**:
```rust
let x = vec![];  // 何のベクタ？
// エラー: type annotations needed
```

**解決策 - 型を明示**:
```rust
let x: Vec<i32> = vec![];  // i32のベクタ
```

または、使用方法で推論させる:
```rust
let x = vec![];
x.push(5);  // i32 を追加 → Vec<i32> と推論される
```

### 数値リテラルの特殊ケース

整数リテラルは、使われるまで型が確定しません：

```rust
let x = 5;  // まだ確定していない
let y: i64 = x;  // ここで i64 と確定
```

これにより、柔軟な型推論が可能です：

```rust
fn takes_i32(n: i32) {}
fn takes_i64(n: i64) {}

let x = 42;
takes_i32(x);  // OK: x は i32

let y = 42;
takes_i64(y);  // OK: y は i64
```

## 対話形式の教え方ガイド（先生用）

### 導入

「型推論は便利じゃが、どうやって型を決めているか不思議じゃろう？実は3つの情報源があるのじゃ」

なぜこれを知っておくと便利か：
- 型エラーが出たとき、原因を理解できる
- 型を明示すべき場面が分かる
- Rustのコンパイラを信頼できる

### 説明の流れ

1. **リテラルから推論を示す**
   ```rust
   let x = 5;
   let y = 5.5;
   let z = true;
   ```
   「これらの型は何じゃと思う？」

2. **操作から推論を示す**
   ```rust
   let x = 5;      // i32
   let y = x + 2;  // x が i32 なので y も i32
   let z = y * 3;  // y が i32 なので z も i32
   ```
   「型が連鎖的に推論されるのじゃ」

3. **推論失敗の例を見せる**
   ```rust
   let numbers = vec![];
   // エラー！
   ```
   「何のベクタか分からんのじゃ。これは明示が必要じゃ」

4. **解決方法を示す**
   ```rust
   // 方法1: 型を明示
   let numbers: Vec<i32> = vec![];

   // 方法2: 使用方法で推論
   let numbers = vec![];
   numbers.push(42);  // i32 を追加 → Vec<i32>
   ```

5. **実験させる**
   「試しに、型を明示せずにベクタを作って、要素を追加してみるのじゃ」

### 実践課題（オプション）

1. 型推論が成功する例と失敗する例を書く
2. 意図的に型を曖昧にして、エラーメッセージを確認
3. 型を明示する方法と、使用方法で推論させる方法の両方を試す

## クリア条件（オプション）

理解度チェック：
- [ ] 型推論の3つの情報源を説明できる
- [ ] 型推論が失敗する場面を理解している
- [ ] 型を明示する方法を知っている

## 補足情報

### ターボフィッシュ構文

ジェネリック関数の型を明示する特殊な構文：

```rust
let x = "42".parse::<i32>().unwrap();
//                  ^^^^^^ ターボフィッシュ
```

### 型推論の限界

Rustの型推論は「ローカル」です。関数の境界を越えて推論することはありません：

```rust
fn mystery() {
    let x = vec![];  // エラー: 型が不明
    x
}
```

関数の戻り値の型は明示する必要があります。

### 参考リンク

- The Rust Book: https://doc.rust-lang.org/book/ch03-02-data-types.html
- Rust by Example: https://doc.rust-lang.org/rust-by-example/types/inference.html
