# トピック: 符号付きと符号なし整数

## メタ情報

- **ID**: signed-unsigned
- **難易度**: 初級
- **所要時間**: 6-8分（対話形式）/ 3-4分（読み物）
- **カテゴリ**: 変数・型

## 前提知識

- Stage 3完了（変数と型）
- 整数型の基本

## このトピックで学べること

- 符号付き（signed）と符号なし（unsigned）の違い
- それぞれの範囲
- いつどちらを使うべきか

## 関連ステージ

- Stage 3: 変数と型（ここで登場）

## 要点（ドキュメント形式用）

### 符号付き（signed）と符号なし（unsigned）

**符号付き (i で始まる)**:
- 負の数と正の数を表現できる
- `i8`, `i16`, `i32`, `i64`, `i128`, `isize`

**符号なし (u で始まる)**:
- 0 以上の数のみ
- `u8`, `u16`, `u32`, `u64`, `u128`, `usize`

### 範囲の違い

**i32 (符号付き32ビット)**:
- 範囲: -2,147,483,648 から 2,147,483,647
- 約 -21億 から 21億

**u32 (符号なし32ビット)**:
- 範囲: 0 から 4,294,967,295
- 約 0 から 42億

同じビット数でも、符号なしの方が大きい正の数を表現できます。

### ビット数による範囲

| 型 | 最小値 | 最大値 |
|----|--------|--------|
| i8 | -128 | 127 |
| u8 | 0 | 255 |
| i16 | -32,768 | 32,767 |
| u16 | 0 | 65,535 |
| i32 | -2,147,483,648 | 2,147,483,647 |
| u32 | 0 | 4,294,967,295 |

### いつ使い分けるか

**符号付き (i32, i64, etc.) を使う場合**:
- デフォルトはこれ
- 負の数が必要な場合
- 一般的な数値計算

```rust
let temperature: i32 = -5;  // 氷点下の温度
let balance: i64 = -1000;   // マイナス残高
```

**符号なし (u8, u32, etc.) を使う場合**:
- 負の数が絶対に発生しない場合
- バイトデータ（u8）
- 配列のインデックス（usize）
- カウンター（必ず0以上）

```rust
let age: u8 = 25;           // 年齢（負にならない）
let count: u32 = 1000;      // カウント
let bytes = vec![0u8, 1u8]; // バイトデータ
```

### 注意点

**符号なしで負の数を扱うとエラー**:
```rust
let x: u32 = -5;  // コンパイルエラー！
```

**オーバーフロー**:
```rust
let x: u8 = 255;
// let y = x + 1;  // デバッグビルドではパニック
```

## 対話形式の教え方ガイド（先生用）

### 導入

「`i32` と `u32` の違いは何じゃと思う？`i` と `u` は重要な意味があるのじゃ」

なぜこれを知っておくと便利か：
- 適切な型を選べる
- メモリを効率的に使える
- エラーを防げる

### 説明の流れ

1. **基本的な違いを示す**
   ```rust
   let x: i32 = -5;    // OK: 負の数
   // let y: u32 = -5; // エラー！
   let z: u32 = 5;     // OK: 正の数
   ```
   「符号なしは負の数を扱えないのじゃ」

2. **範囲の違いを説明**
   ```rust
   let max_i8: i8 = 127;
   let max_u8: u8 = 255;
   ```
   「同じ8ビットでも、u8の方が大きい正の数を扱えるのじゃ」

3. **実用例を示す**
   ```rust
   // 年齢は負にならない
   let age: u8 = 25;

   // 温度は負になる可能性
   let temperature: i32 = -5;
   ```

4. **オーバーフローを体験**
   ```rust
   let x: u8 = 255;
   println!("max: {}", x);
   // let y = x + 1;  // これを試すとどうなる？
   ```

5. **デフォルトの説明**
   「迷ったら i32 を使うのじゃ。これがRustのデフォルトじゃ」

### 実践課題（オプション）

1. 符号付きと符号なしで異なる変数を作る
2. u8 の最大値（255）を超える操作を試す
3. 実際のプログラムでどちらを使うべきか考える

## クリア条件（オプション）

理解度チェック：
- [ ] 符号付きと符号なしの違いを説明できる
- [ ] それぞれの範囲を理解している
- [ ] いつどちらを使うべきか判断できる

## 補足情報

### ラッピング（wrapping）

オーバーフロー時の動作を制御できます：

```rust
let x: u8 = 255;
let y = x.wrapping_add(1);  // 0 になる（ラップアラウンド）
```

### チェック付き演算

```rust
let x: u8 = 255;
let y = x.checked_add(1);  // None を返す
```

### なぜusizeが必要か

配列のインデックスは `usize` 型です：

```rust
let arr = [1, 2, 3];
let index: usize = 0;
println!("{}", arr[index]);
```

これは、配列のサイズがアーキテクチャ（32ビット/64ビット）に依存するためです。

### 参考リンク

- The Rust Book: https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types
- Rust by Example: https://doc.rust-lang.org/rust-by-example/primitives/literals.html
