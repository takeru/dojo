# トピック: マクロ入門（println!の`!`の意味）

## メタ情報

- **ID**: macros-intro
- **難易度**: 初級
- **所要時間**: 10-15分（対話形式）/ 3-5分（読み物）
- **カテゴリ**: 言語機能

## 前提知識

- Stage 2完了（Hello World）
- println!を使ったことがある

## このトピックで学べること

- `!` がついている理由
- マクロと関数の違い
- よく使うマクロの紹介

## 関連ステージ

- Stage 2: Hello World（println!で登場）
- Stage 6以降: 独自マクロの作成

## 要点（ドキュメント形式用）

### `!` は「マクロ」の印

`println!` の最後の `!` は、これが「マクロ」であることを示しています。

```rust
// マクロ（!がつく）
println!("Hello");

// 関数（!がつかない）
std::process::exit(0);
```

### マクロと関数の違い

| | マクロ | 関数 |
|---|--------|------|
| 呼び出し | `println!(...)` | `exit(...)` |
| 引数の数 | 可変（何個でもOK） | 固定 |
| 処理タイミング | コンパイル時 | 実行時 |
| 型チェック | コンパイル時 | コンパイル時 |

### なぜマクロが必要か？

**可変長引数が使える**:
```rust
println!("1つ: {}", a);
println!("2つ: {} と {}", a, b);
println!("3つ: {} {} {}", a, b, c);
```

関数だとこれができません（引数の数が決まっているため）。

**コンパイル時にコード生成**:
マクロは、コンパイル時に展開されて最適化されます。

### よく使うマクロ

```rust
// ベクタを作る
let v = vec![1, 2, 3, 4, 5];

// 文字列をフォーマット
let s = format!("Hello, {}", name);

// プログラムを終了（パニック）
panic!("エラーが発生しました！");

// デバッグ出力
println!("デバッグ: {:?}", some_value);
dbg!(some_value);

// アサーション（テストで使う）
assert_eq!(1 + 1, 2);
assert!(x > 0);
```

### マクロの見分け方

名前の最後に `!` がついていれば、それはマクロです。

## 対話形式の教え方ガイド（先生用）

### 導入

「println!の最後についている `!` が気になったじゃろう？これは『マクロ』という特別な機能の印なのじゃ」

なぜこれを知っておくと便利か：
- Rustのコードを読むとき、マクロと関数を区別できる
- マクロの強力な機能を活用できる
- エラーメッセージが理解しやすくなる

### 説明の流れ

1. **マクロと関数の違いを実演**
   ```rust
   // main.rsで試してもらう
   fn main() {
       // マクロ: 引数の数が変えられる
       println!("1つ: {}", 10);
       println!("2つ: {} {}", 10, 20);
       println!("3つ: {} {} {}", 10, 20, 30);

       // これが関数だったら、引数の数ごとに
       // 別々の関数が必要になる
   }
   ```

2. **vec!マクロを試させる**
   ```rust
   fn main() {
       let numbers = vec![1, 2, 3, 4, 5];
       println!("ベクタ: {:?}", numbers);
   }
   ```
   「vec!は配列のようなものを簡単に作るマクロじゃ。何個でも要素を入れられるぞ」

3. **format!マクロを試させる**
   ```rust
   fn main() {
       let name = "太郎";
       let greeting = format!("こんにちは、{}さん！", name);
       println!("{}", greeting);
   }
   ```
   「format!はprintln!と似ておるが、画面に出力せず、文字列を作るだけじゃ」

4. **マクロ展開を覗いてみる（オプション）**
   ```bash
   cargo expand
   ```
   （cargo-expand がインストールされていれば）
   「マクロがどんなコードに展開されるか見られるぞ」

### 実践課題（オプション）

1. println!で様々な数の引数を試す
2. vec!で好きな数値のベクタを作る
3. format!で文字列を組み立てる
4. dbg!マクロを使ってデバッグ出力してみる

## クリア条件（オプション）

理解度チェック：
- [ ] `!` がついているものはマクロだと分かる
- [ ] マクロと関数の違いを1つ以上説明できる
- [ ] println! 以外のマクロを2つ以上使える

## 補足情報

### マクロの種類

Rustには複数の種類のマクロがあります：

1. **宣言的マクロ**（`macro_rules!`）
   - `println!`、`vec!` など
   - パターンマッチングでコード生成

2. **手続き的マクロ**（より高度）
   - カスタムの derive（`#[derive(Debug)]`）
   - 属性マクロ
   - Stage 6以降で詳しく学びます

### デバッグに便利なマクロ

```rust
// 変数の値と名前を表示
let x = 42;
dbg!(x);  // [src/main.rs:2] x = 42

// 複数の値を一度に
dbg!(a, b, c);

// println!との違い
println!("{:?}", x);  // 値だけ
dbg!(x);              // ファイル名、行番号、変数名、値
```

### 参考リンク

- The Rust Book - Macros: https://doc.rust-lang.org/book/ch19-06-macros.html
- Rust by Example - Macros: https://doc.rust-lang.org/rust-by-example/macros.html
