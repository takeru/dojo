# トピック: 数値リテラルのサフィックス

## メタ情報

- **ID**: numeric-suffixes
- **難易度**: 初級
- **所要時間**: 5-7分（対話形式）/ 2-3分（読み物）
- **カテゴリ**: 変数・型

## 前提知識

- Stage 3完了（変数と型）
- 整数・浮動小数点数の基本型

## このトピックで学べること

- 数値リテラルにサフィックスをつける方法
- サフィックスと型推論の関係
- いつサフィックスを使うべきか

## 関連ステージ

- Stage 3: 変数と型（ここで登場）

## 要点（ドキュメント形式用）

### 数値リテラルのサフィックスとは

数値に型名をくっつけることで、型推論をオーバーライドできます：

```rust
let x = 5i32;    // i32 として明示
let y = 5u8;     // u8 として明示
let z = 5.0f32;  // f32 として明示（デフォルトはf64）
```

### 整数のサフィックス

| サフィックス | 型 |
|------------|-----|
| `i8` | 符号付き8ビット |
| `i16` | 符号付き16ビット |
| `i32` | 符号付き32ビット（デフォルト） |
| `i64` | 符号付き64ビット |
| `i128` | 符号付き128ビット |
| `u8` | 符号なし8ビット |
| `u16` | 符号なし16ビット |
| `u32` | 符号なし32ビット |
| `u64` | 符号なし64ビット |
| `u128` | 符号なし128ビット |

### 浮動小数点のサフィックス

| サフィックス | 型 |
|------------|-----|
| `f32` | 単精度浮動小数点 |
| `f64` | 倍精度浮動小数点（デフォルト） |

### 型明示との違い

**型明示**:
```rust
let x: i32 = 5;
```

**サフィックス**:
```rust
let x = 5i32;
```

どちらも同じ結果ですが、サフィックスはリテラルの時点で型が確定します。

### いつ使うか

**1. 型推論が曖昧な場合**:
```rust
let numbers = vec![1u8, 2u8, 3u8];  // Vec<u8> と明確に
```

**2. 演算で型を合わせる場合**:
```rust
let x: u32 = 10;
let y = x + 5u32;  // 5も u32 として扱う
```

**3. f32を明示したい場合**:
```rust
let pi = 3.14f32;  // デフォルトの f64 ではなく f32
```

### アンダースコアで読みやすく

大きな数字には `_` を使えます：

```rust
let million = 1_000_000i32;
let billion = 1_000_000_000u64;
```

## 対話形式の教え方ガイド（先生用）

### 導入

「数字に `i32` とか `u8` とかくっつけるのを見たことがあるじゃろう？これはサフィックスと呼ばれる便利な機能じゃ」

なぜこれを知っておくと便利か：
- 型推論に頼らず、明示的に型を指定できる
- コードの意図が明確になる
- 型エラーを防げる

### 説明の流れ

1. **基本的な例**
   ```rust
   let x = 5;       // i32 (デフォルト)
   let y = 5i64;    // i64 (サフィックスで明示)
   let z = 5u8;     // u8 (サフィックスで明示)
   ```
   「それぞれの型を確認してみるのじゃ」

2. **実用例を示す**
   ```rust
   let bytes = vec![0u8, 1u8, 2u8, 3u8];  // バイト配列
   ```
   「バイトデータを扱うとき、u8 サフィックスが便利じゃ」

3. **f32の例**
   ```rust
   let x = 3.14;      // f64 (デフォルト)
   let y = 3.14f32;   // f32 (メモリ節約)
   ```

4. **アンダースコアの紹介**
   ```rust
   let million = 1_000_000i32;
   println!("百万: {}", million);
   ```

5. **実験させる**
   「試しに、異なるサフィックスで数値を作ってみるのじゃ」

### 実践課題（オプション）

1. u8, i32, f32 のサフィックスを使った変数を作る
2. アンダースコアを使って大きな数字を読みやすく書く
3. サフィックスなしとサフィックスありで型エラーの違いを確認

## クリア条件（オプション）

理解度チェック：
- [ ] 数値リテラルにサフィックスをつけられる
- [ ] サフィックスと型推論の違いを理解している
- [ ] アンダースコアで数字を読みやすくできる

## 補足情報

### 16進数、8進数、2進数のサフィックス

サフィックスは他の基数でも使えます：

```rust
let hex = 0xFFu8;       // 16進数 + u8
let oct = 0o77i32;      // 8進数 + i32
let bin = 0b1010u32;    // 2進数 + u32
```

### isize / usize

ポインタサイズの整数にもサフィックスがあります：

```rust
let index = 5usize;
let offset = -10isize;
```

### 参考リンク

- The Rust Book: https://doc.rust-lang.org/book/ch03-02-data-types.html#numeric-types
- Rust by Example: https://doc.rust-lang.org/rust-by-example/primitives/literals.html
